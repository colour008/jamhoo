---
title: C 语言链表 🍁
date: 2024-12-01 12:00:00
updated: 2024-12-01 12:00:00
tag: [C语言,链表]
categories: [编程,C语言]
cover:
description: C 语言链表 🍁
swiper_index: 8
sticky: 8
---

------

# 一、 什么是链表

## 1. 链表的定义

> 链表是**一种物理存储单元上非连续、非顺序的存储结构**，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列**结点**（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的**数据域**，另一个是存储下一个结点地址的**指针域**。

## 2. 顺序存储和链式存储

### （1）数组 — 顺序存储

数组作为一个顺序储存方式的数据结构，可是有大作为的，它的灵活使用为我们的程序设计带来了大量的便利；但数组最大的缺点就是我们的插入和删除时需要移动大量的元素，所以，很多人想到需要大量的消耗时间，以及冗余度就想放弃或寻求别的方法。以 C 语言数组插入一个元素为例，当我们需要在一个数组 `{1,2,3,4}` 的第 `1` 个元素后的位置插入一个`’A’`时，我们需要做的有：

1. 将第 `1` 个元素后的整体元素后移，形成新的数组 `{1,2,2,3,4}`
2. 再将第 `2` 个元素位置的元素替换为我们所需要的元素`’A’`
3. 最终形成我们的预期，这需要很多的操作喔。

![数组—顺序存储](https://bu.dusays.com/2025/01/05/677a71b1b68c6.jpg)

上图可以看出，使用数组都有这两大缺点：

1. 插入删除操作所需要移动的元素很多，浪费算力。
2. 必须为数组开足够的空间，否则有溢出风险。

### （2）链表 — 链式存储

由于数组的这些缺点，自然而然的就产生链表的思想。链表通过不连续的储存方式，自适应内存大小，以及指针的灵活使用，巧妙的简化了上述的内容。链表的基本思维是，利用**结构体**的设置，额外开辟出一份内存空间去作指针，它总是指向下一个结点，一个个结点通过 `NEXT` 指针相互串联，就形成了链表。

![链表—链式存储](https://bu.dusays.com/2025/01/05/677a71b1969d6.png)

其中 `DATA` 为自定义的数据类型，`NEXT` 为指向下一个链表结点的指针，通过访问 `NEXT`，可以引导我们去访问链表的下一个结点。

对于一连串的结点而言，就形成了链表如下图：

![一连串的结点形成链表](https://bu.dusays.com/2025/01/05/677a71b1abf38.jpg)

相比起数组，链表解决了数组不方便移动，插入，删除元素的弊端，但相应的，链表付出了更加大的内存牺牲换来的这些功能的实现。

## 3. 链表概述

包含[单链表](http://127.0.0.1:51634/2023/01/26/C语言链表/#singlyList)，双链表，循环单链表，实际应用中的功能不同，但实现方式都差不多。

![链表概述](https://bu.dusays.com/2025/01/05/677a71b1b371a.jpg)

## 4. 链表与数组的区别

数组是相同数据类型的元素按一定顺序排列的集合。根据概念我们可以知道数组在内存中连续，链表不连续；由于不同的存储方式导致**数组静态分配内存，链表动态分配内存，数组元素在栈区，链表元素在堆区**；由于数组在内存中连续，我们可以利用下标定位，时间复杂度为 `O(1)`，链表定位元素时间复杂度 `O(n)`；但是由于数组的连续性数组插入或删除元素的时间复杂度 `O(n)`，链表的时间复杂度 `O(1)`。总结一下，数组和链表的区别如下：

1. 数组静态分配内存，链表动态分配内存
2. 数组在内存中连续，链表不连续
3. 数组元素在栈区，链表元素在堆区
4. 数组利用下标定位，时间复杂度为`O(1)`，链表定位元素时间复杂度`O(n)`；
5. 数组插入或删除元素的时间复杂度`O(n)`，链表的时间复杂度`O(1)`。

# 二、 单链表

## 1. 定义

单链表是一种链式存取的数据结构，链表中的数据是以结点来表示的，每个结点的构成：元素 (数据元素的映象) + 指针 (指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。**以 “结点的序列” 表示的线性表称作线性链表（单链表），单链表是链式存取的结构**。

接下来我们从创建链表 -> 创建节点 -> 插入节点（也称新增节点）-> 释放节点（也称删除节点）-> 编辑节点（也称修改节点）-> 查找节点（也称检索节点）-> 释放链表，一步一步地实现链表的创建和节点的增删改查。

## 2. 单向链表的程序设计

### （1）定义结构体

对于链表的每一个结点，我们使用结构体 `struct` 进行设计，其主要内容有：

![单链表节点结构](https://bu.dusays.com/2025/01/05/677a71b1962b8.png)

其中，`DATA` 数据元素，可以为你想要储存的任何数据格式，可以是数组，可以是 `int`，甚至可以是`结构体`（这就是传说中的结构体套结构体）。`NEXT` 为一个指针，其代表了一个可以指向的区域，通常是用来指向下一个结点，链表的尾部 `NEXT` 指向 `NULL（空）`，因为尾部没有任何可以指向的空间了。具体示例代码如下：

```cpp
// 链表节点结构体
typedef struct node
{
    int data;          // 节点存储的数据
    struct node *next; // 指向下一个节点的指针
} Node;
```

代码中，结构体中包含两个成员：`data` 和 `next`。`data` 用于存储节点存储的数据，`next` 用于指向下一个节点的指针。结构体定义了一种名为 `Node` 的类型，这个类型可以用来创建链表节点。

### （2）完整代码示例

链表增删改查函数实现示例：

```cpp
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

// 链表节点结构体
typedef struct node
{
    int data;          // 节点存储的数据
    struct node *next; // 指向下一个节点的指针
} Node;

// 创建链表
Node *CreatList()
{
    Node *HeadNode = (Node *)malloc(sizeof(Node)); // 创建链表头节点
    assert(HeadNode);                              // 断言确保内存分配成功
    HeadNode->next = NULL;                         // 头节点的下一个节点指针指向空
    return HeadNode;                               // 返回链表头节点指针
}

// 创建节点
Node *CreatNode(int data)
{
    Node *NewNode = (Node *)malloc(sizeof(Node)); // 创建新节点
    assert(NewNode);                              // 断言确保内存分配成功
    NewNode->data = data;                         // 设置节点存储的数据
    NewNode->next = NULL;                         // 新节点的下一个节点指针指向空
    return NewNode;                               // 返回新节点指针
}

// 在链表头部插入节点
void InsertHead(Node *HeadNode, int data)
{
    Node *FirstNode = CreatNode(data); // 创建要插入的数据对应的节点
    FirstNode->next = HeadNode->next; // 将插入节点的下一个节点指针指向原链表头节点的下一个节点
    HeadNode->next = FirstNode;       // 将链表头节点的下一个节点指针指向插入的节点
}

// 在链表尾部插入节点
void InsertTail(Node *HeadNode, int data)
{
    Node *LastNode = CreatNode(data); // 创建要插入的数据对应的节点
    Node *pmove = HeadNode;           // 创建一个指针pmove，初始指向链表头节点
    while (pmove->next != NULL)       // 遍历链表直到找到最后一个节点
    {
        pmove = pmove->next; // 将pmove指向下一个节点
    }
    pmove->next = LastNode; // 将最后一个节点的下一个节点指针指向新插入的节点
}

// 在指定位置插入节点
void InsertAppoin(Node *HeadNode, int posData, int data)
{
    Node *PreNode = HeadNode;       // 创建一个指针PreNode，初始指向链表头节点
    Node *CurNode = HeadNode->next; // 创建一个指针CurNode，初始指向链表头节点的下一个节点
    while (CurNode != NULL && CurNode->data != posData) // 遍历链表直到找到距离指定位置最近的节点或者找到指定位置
    {
        PreNode = CurNode;       // 将PreNode指向当前节点
        CurNode = CurNode->next; // 将CurNode指向下一个节点
    }
    if (CurNode == NULL) // 如果未找到指定位置，打印相关提示
    {
        printf("未找到，无法插入！\n");
    }
    else
    {
        Node *NewNode = CreatNode(data); // 创建要插入的数据对应的节点
        NewNode->next = CurNode;         // 将插入节点的下一个节点指针指向当前节点
        PreNode->next = NewNode;         // 将上个节点的下一个节点指针指向插入的节点
    }
}

// 在指定位置插入节点
void InsertIndex(Node *HeadNode, int index, int data)
{
    if (index < 0) // 如果指定位置错误
    {
        printf("序号有误，无法插入！\n");
        return;
    }

    Node *PreNode = HeadNode;               // 创建一个指针PreNode，初始指向链表头节点
    Node *CurNode = HeadNode->next;         // 创建一个指针CurNode，初始指向链表头节点的下一个节点
    int move = 0;                           // 创建一个变量move，用于记录已经遍历的节点个数
    while (CurNode != NULL && move < index) // 遍历链表直到找到指定位置或者遍历完所有节点
    {
        PreNode = CurNode;       // 将PreNode指向当前节点
        CurNode = CurNode->next; // 将CurNode指向下一个节点
        move++;                  // 更新move的值
    }
    if (CurNode == NULL) // 如果未找到指定位置，打印相关提示
    {
        printf("序号有误，无法插入！\n");
    }
    else
    {
        Node *NewNode = CreatNode(data); // 创建要插入的数据对应的节点
        NewNode->next = CurNode;         // 将插入节点的下一个节点指针指向当前节点
        PreNode->next = NewNode;         // 将上个节点的下一个节点指针指向插入的节点
    }
}

// 删除链表头节点
void DeleteHead(Node *HeadNode)
{
    Node *DeleteNode = HeadNode->next; // 创建一个指针DeleteNode，指向链表头节点的下一个节点
    if (DeleteNode == NULL)            // 如果链表为空，打印相关提示，直接返回
    {
        printf("链表为空，无法删除！\n");
        return;
    }
    else
    {
        HeadNode->next = DeleteNode->next; // 将链表头节点的下一个节点指针指向删除节点的下一个节点
        free(DeleteNode);                  // 释放删除节点的内存空间
        DeleteNode = NULL;                 // 将deleteNode指针置为空
    }
}

// 删除链表尾节点
void DeleteTail(Node *HeadNode)
{
    Node *PreNode = HeadNode;       // 创建一个指针PreNode，初始指向链表头节点
    Node *CurNode = HeadNode->next; // 创建一个指针CurNode，初始指向链表头节点的下一个节点
    if (CurNode == NULL)            // 如果链表为空，打印相关提示，直接返回
    {
        printf("链表为空，无法删除！\n");
        return;
    }

    while (CurNode->next != NULL) // 遍历链表直到找到最后一个节点
    {
        PreNode = CurNode;       // 将PreNode指向当前节点
        CurNode = CurNode->next; // 将CurNode指向下一个节点
    }
    free(CurNode);        // 释放最后一个节点的内存空间
    CurNode = NULL;       // 将CurNode指针置为空
    PreNode->next = NULL; // 将PreNode节点的下一个节点指针置为NULL
}

// 删除指定数据的节点
void DeleteAppoin(Node *HeadNode, int PosData)
{
    Node *PreNode = HeadNode;       // 创建一个指针PreNode，初始指向链表头节点
    Node *CurNode = HeadNode->next; // 创建一个指针CurNode，初始指向链表头节点的下一个节点
    while (CurNode != NULL && CurNode->data != PosData) // 遍历链表直到找到指定数据或者找到指定数据
    {
        PreNode = CurNode;       // 将PreNode指向当前节点
        CurNode = CurNode->next; // 将CurNode指向下一个节点
    }
    if (CurNode == NULL) // 如果未找到指定数据，打印相关提示
    {
        printf("未找到，无法删除！\n");
    }
    else
    {
        PreNode->next = CurNode->next; // 将PreNode节点的下一个节点指针指向删除节点的下一个节点
        free(CurNode);                 // 释放删除节点的内存空间
        CurNode = NULL;                // 将CurNode指针置为空
    }
}

// 删除指定位置的节点
void DeleteIndex(Node *HeadNode, int Index)
{
    Node *PreNode = HeadNode;               // 创建一个指针PreNode，初始指向链表头节点
    Node *CurNode = HeadNode->next;         // 创建一个指针CurNode，初始指向链表头节点的下一个节点
    int move = 0;                           // 创建一个变量move，用于记录已经遍历的节点个数
    while (CurNode != NULL && move < Index) // 遍历链表直到找到指定位置或者遍历完所有节点
    {
        PreNode = CurNode;       // 将PreNode指向当前节点
        CurNode = CurNode->next; // 将CurNode指向下一个节点
        move++;                  // 更新move的值
    }
    if (CurNode == NULL) // 如果未找到指定位置，打印相关提示
    {
        printf("未找到，无法删除！\n");
    }
    else
    {
        PreNode->next = CurNode->next; // 将PreNode节点的下一个节点指针指向删除节点的下一个节点
        free(CurNode);                 // 释放删除节点的内存空间
        CurNode = NULL;                // 将CurNode指针置为空
    }
}

// 根据指定数据查找节点，并返回节点指针
Node *SearchAppoin(Node *HeadNode, int PosData)
{
    Node *CurNode = HeadNode->next; // 创建一个指针CurNode，初始指向链表头节点的下一个节点
    while (CurNode != NULL && CurNode->data != PosData) // 遍历链表直到找到指定数据或者遍历完所有节点
    {
        CurNode = CurNode->next; // 将CurNode指向下一个节点
    }
    if (CurNode == NULL) // 如果未找到指定数据，打印相关提示
    {
        printf("数据错误未找到！\n");
        return NULL; // 返回空指针
    }
    else
    {
        return CurNode; // 返回找到的节点指针
    }
}
// 寻找指定索引的节点
Node *SearchIndex(Node *HeadNode, int index)
{
    if (index < 0) // 判断索引是否小于0
    {
        printf("序号错误未找到！\n"); // 输出错误提示
        return NULL;                  // 返回空指针
    }
    else
    {
        Node *CurNode = HeadNode->next; // 定义指向当前节点的指针，并指向头节点的下一个节点
        int move = 0;                   // 初始化移动次数为0
        while (CurNode != NULL && move < index) // 循环条件为当前节点不为空且移动次数小于索引
        {
            CurNode = CurNode->next; // 将当前节点指向当前节点的下一个节点
            move++;                  // 移动次数加1
        }
        if (CurNode == NULL) // 如果当前节点为空
        {
            printf("序号错误未找到！\n"); // 输出错误提示
            return NULL;                  // 返回空指针
        }
        else
        {
            return CurNode; // 返回找到的节点
        }
    }
}

// 修改指定位置的数据
void EditAppoin(Node *HeadNode, int PosData, int data)
{
    Node *CurNode = HeadNode->next; // 定义指向当前节点的指针，并指向头节点的下一个节点
    while (CurNode != NULL && CurNode->data != PosData) // 循环条件为当前节点不为空且当前节点的数据不等于指定位置的数据
    {
        CurNode = CurNode->next; // 将当前节点指向当前节点的下一个节点
    }
    if (CurNode == NULL) // 如果当前节点为空
    {
        printf("未找到指定数据无法编辑！\n"); // 输出错误提示
    }
    else
    {
        CurNode->data = data; // 修改当前节点的数据为指定的数据
    }
}

// 修改指定索引的数据
void EditIndex(Node *HeadNode, int index, int data)
{
    Node *CurNode = HeadNode->next;         // 定义指向当前节点的指针，并指向头节点的下一个节点
    int move = 0;                           // 初始化移动次数为0
    while (CurNode != NULL && move < index) // 循环条件为当前节点不为空且移动次数小于索引
    {
        CurNode = CurNode->next; // 将当前节点指向当前节点的下一个节点
        move++;                  // 移动次数加1
    }
    if (CurNode == NULL) // 如果当前节点为空
    {
        printf("未找到指定数据无法编辑！\n"); // 输出错误提示
    }
    else
    {
        CurNode->data = data; // 修改当前节点的数据为指定的数据
    }
}

// 释放链表占用的内存
void FreeList(Node *HeadNode)
{
    Node *CurNode = NULL;    // 定义指向当前节点的指针，并初始化为空指针
    while (HeadNode != NULL) // 循环条件为头节点不为空
    {
        CurNode = HeadNode;        // 将当前节点指向头节点
        HeadNode = HeadNode->next; // 将头节点指向头节点的下一个节点
        free(CurNode);             // 释放当前节点占用的内存
        CurNode = NULL;            // 将当前节点指针初始化为空指针
    }
}


// 打印链表中的数据
void PrintList(Node *HeadNode)
{
    Node *pmove = HeadNode->next; // 定义指针pmove，并指向头节点的下一个节点
    if (pmove == NULL)            // 如果pmove为空指针
    {
        printf("链表为空！\n"); // 输出提示信息
        return;                 // 结束函数
    }
    while (pmove != NULL) // 循环条件为pmove不为空指针
    {
        printf("%d ", pmove->data); // 输出pmove节点的数据
        pmove = pmove->next;        // 将pmove指向pmove的下一个节点
    }
    printf("\n");
}

int main()
{
    Node *list = CreatList();   // 创建链表
    PrintList(list);            // 打印链表
    for (int i = 0; i < 3; i++) // 循环3次
    {
        InsertHead(list, i); // 在链表头部插入数据
    }
    PrintList(list);                              // 打印链表
    InsertTail(list, 666);                        // 在链表尾部插入数据
    PrintList(list);                              // 打印链表
    InsertAppoin(list, 666, 999);                 // 在指定位置插入数据
    PrintList(list);                              // 打印链表
    InsertIndex(list, 2, 888);                    // 在指定索引插入数据
    PrintList(list);                              // 打印链表
    DeleteHead(list);                             // 删除链表头部节点
    PrintList(list);                              // 打印链表
    DeleteTail(list);                             // 删除链表尾部节点
    PrintList(list);                              // 打印链表
    DeleteAppoin(list, 0);                        // 删除指定位置的节点
    PrintList(list);                              // 打印链表
    DeleteIndex(list, 0);                         // 删除指定索引的节点
    PrintList(list);                              // 打印链表
    Node *SearchByData = SearchAppoin(list, 999); // 根据数据查找节点
    if (SearchByData)                             // 如果找到的节点不为空
    {
        printf("%d\n", SearchByData->data); // 输出找到的节点的数据
    }
    Node *SearchByIndex = SearchIndex(list, 0); // 根据索引查找节点
    if (SearchByIndex)                          // 如果找到的节点不为空
    {
        printf("%d\n", SearchByIndex->data); // 输出找到的节点的数据
    }
    EditAppoin(list, 888, 555); // 修改指定位置的数据
    PrintList(list);            // 打印链表
    EditIndex(list, 1, 777);    // 修改指定索引的数据
    PrintList(list);            // 打印链表
    FreeList(list);             // 释放链表占用的内存
    system("pause");
    return 0;
}
```

